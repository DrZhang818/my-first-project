#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> PII;
typedef unsigned long long ull;
const int inf = 1000000000;

//https://codeforces.com/contest/1110/problem/D
/*
    DP || 贪心
    题意:
        你有N张牌, 有以下两种特殊牌型
        顺子: 三张连续排序后在自然数集上连续的牌
        刻子: 三张相同的牌
        给定M, 表示每张牌的数值在[1,M]之间
        请你求出你的手牌最多能组成多少个特殊牌型, 每张牌只能用一次
        范围: N∈[1,1e6], M∈[1,1e6]
    关键思考:
        本题为决策类题目, 常用思考方式为: 暴力->DP||贪心, 常用优化手段为: 二分、前缀和、双指针、数据结构
        拿到决策类题目, 我们首先尝试将题目转化为 局面 + 问题
        局面: 视角(1)有N张牌
              视角(2)有M种牌, 第i种牌有cnt[i]张
        问题: 当前局面最多能组成多少个特殊牌型
        接下来思考问题的性质与规模, 这一步决定问题的解决方式, 常见方式为暴力、二分答案、贪心、DP
        我们不妨头脑风暴一下, 尝试挖掘出尽可能多的问题性质:
        (1)答案一定为[0,N/3]之间的某个整数
        (2)问题相当于从数组中选取子集, 因此我们可以对数组做任意排序, 不会影响原问题答案
        (3)x张相同的牌至少能贡献x/3个刻子
        (4)三个相同顺子可以拆成三个刻子, 利用这点, 每组牌只需要考虑拿出0~2张与其他牌组成顺子
        根据以上性质, 我们考虑选择哪种解决问题的方式
        暴力显然是不行, 二分也不成立, 因为二分答案后的check仍要求我们解决原问题
        贪心能否成立呢? 从性质(4)我们能看出, 部分贪心是有正确性的, 我们只需要某种手牌有0~4张的
        情况怎么打就可以了. 但对于这0~4张的安排我们不可继续贪心了, 必须考虑DP
        本题最难的就是如何划分局面了
        显然, 由于问题是与值相关的, 我们用视角(2)来进行思考
        考虑前i种牌: 
            第i种牌的决策与什么有关呢?
            显然, 与第i种、第i-1种、第i-2种牌的数量有关
            但更进一步呢? 对于i-1和i-2, 我们不能要它们的全部数量, 只能讨论还剩多少张没被选择
            时的决策
            但对于第i种, 我们又要考虑它的全部数量, 但是转移后又要得到还剩多少张没选时的决策
            总之, 状态转移十分复杂
        我们考虑换一种划分方式
        考虑前i种顺子, 第i种顺子代表三元组(i,i+1,i+2):
            第i种顺子的决策与什么有关呢?
            与第i种牌的数量,第i-1种和第i-2种顺子的决策有关
            定义dp[i][x][y] := 组成x个第i-1种顺子, y个第i种顺子时得到的最多个数
            初始值为dp[0][0][0] = 0
            下面考虑状态转移:
            设第i种牌有cnt个
            我们枚举第i-2种顺子的个数z, 省略dp第一维
            由于第i-2,i-1,i种顺子都会消耗第i种牌的数量
            有转移方程: ndp[x][y] = max{ dp[z][x] + (cnt-x-y-z)/3 + y }
        由于第m-1种顺子和第m种顺子不存在
        因此答案为 dp[0][0]
*/
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> cnt(m + 1);
    for(int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        cnt[x]++;
    }
    vector dp(3, vector<int>(3, -inf));
    dp[0][0] = 0;
    int ans = 0;
    for(int x = 1; x <= m; x++) {
        int c = cnt[x];
        vector ndp(3, vector<int>(3, -inf));
        for(int i = 0; i < 3; i++) {
            for(int j = 0; j < 3; j++) {
                for(int k = 0; k < 3; k++) {
                    if(i + j + k > c) continue;
                    ndp[j][k] = max(ndp[j][k], dp[i][j] + (c - i - j - k) / 3 + k);
                }
            }
        }
        dp = move(ndp);
    }
    cout << dp[0][0] << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t = 1;
    // cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}