#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> PII;
typedef unsigned long long ull;
const int inf = 1000000000;

//https://codeforces.com/contest/1175/problem/D
/*
    贪心
    题意:
        给定一个长度为N的数组和一个整数k, 你需要把数组分成恰好k段
        从左到右依次给子数组编号为1~k, 定义f(i)表示第i个元素所在的子数组的编号
        最后得到的权值为∑a[i]*f(i), 要求计算出能得到的最大权值
        范围: n∈[1,3e5], k∈[1,n], a[i]∈[-1e6,1e6]
    关键思考:
        本题为决策类题目, 常用思考方式为: 暴力->DP||贪心, 常用优化手段为: 二分、前缀和、双指针、数据结构
        首先观察题目性质, 题目让我们算一个很奇怪的式子, 并且n和k都很大
        我们可以估算下合法状态数量, 状态数量可以指导我们接下来的优化方向
        把n个数划分为k个子段, 这是个经典问题, 方案数为C[n-1][k-1], 数量级为O(2^n)
        这种问题属于状态空间爆炸, 这意味着搜索||DP都不可行, 我们无法枚举所有状态
        接下来思考的就是如何压缩状态: 利用等价关系划分等价类, 贡献法一次性处理大量状态
        我们可能会想到[位置][已划分的段数]这种划分, 但这样状态数是n*k, 仍然过大
        我们会发现, 似乎找不到任何合适的等价关系来进行划分, 问题似乎变得无解...
        所谓横看成岭侧成峰, 远近高低各不同, 我们换个视角来看这个奇怪的式子
        ∑a[i]*cnt[i], 这种形式的式子像是通过贡献法整理出来, 把每个元素打包起来计算
        我们考虑对这个式子进行"解包", 看看会发生什么!
        例如我们把a = [1,2,3,4]划分成了[1][2][3,4]
        得到的是a[1]+a[2]*2+(a[3]+a[4])*3
        我们稍加变形, 神奇地发现变成了
        (a[1]+a[2]+a[3]+a[4])+(a[2]+a[3]+a[4])+(a[3]+a[4])
        即suf[1]+suf[2]+suf[3] = 3*sum - (pre[0] + pre[1] + pre[2])
        以上推导说明, 解包之后我们可以把不同组进行合并
        最后整个式子竟能用后缀和或前缀和来表示!
        这里pre[0]是固定的, 而pre[1]和pre[2]是可以通过调整划分点来改变的
        问题就变成了选出前k-1小的前缀和, 直接排序后贪心选择就好了!
        由于选出的数组不能为空, 因此pre[n]不可选(这会导致最后一段为空)
*/
void solve() {
    int n, k;
    cin >> n >> k;
    vector<ll> a(n + 1);
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        a[i] += a[i - 1];
    }
    ll ans = k * a[n];
    sort(a.begin() + 1, a.end() - 1);
    for(int i = 1; i < k; i++) {
        ans -= a[i];
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t = 1;
    // cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
