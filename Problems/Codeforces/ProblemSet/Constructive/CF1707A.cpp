#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> PII;
typedef unsigned long long ull;


//https://codeforces.com/contest/1707/problem/A
/*
    构造 || 贪心
    题意:
        给定一个长度为N的数组a表示有N个题目, 第i个题目难度为a[i], 最初你的智商为Q
        你需要从左到右来操作, 每个题你有做或不做两种操作
        op1: 进入下一个题目
        op2: 过题数量+1; 如果题目难度大于当前智商, 则当前智商-1
        如果智商变为0, 则立即停止答题
        要求计算出最多能答几个题目, 输出最优方案(0表示不做, 1表示做)
        范围: n∈[1,1e5], q∈[1,1e9], a[i]∈[1,1e9]
    关键思考:
        本题为决策类题目, 常用思考方式为: 暴力->DP||贪心, 常用优化手段为: 二分、前缀和、双指针、数据结构
        首先观察题目性质, 我们目标是最大化op2的数量
        如果当前智商 >= a[i], 我们肯定会选择做第i个题目, 这是显然的, 因为这种操作无代价
        如果当前智商 < a[i], 我们该如何决策呢? 这是本题最难的地方
        由于op2的贡献固定为1, 如果必须要惩罚的话, 我们当然希望惩罚出现的越晚越好
        例如[___3,2,2,2,2,3___], q = 2这个例子
        假设选择第一个3是最优解, 我们可以很轻易地利用交换论证法来证明选择第二个3更优
        对于任意的i,j(i < j), 如果在i位置使用有代价的op2, 在j位置使用op1
        我们可以交换次序, 显然在i位置使用op1, 在j位置使用op2是合法的, 并且这样对于
        [i + 1, j - 1]之间的题目无疑是更优的, 因为我们保持了更高的智商来应对这些题目!
        于是我们就自然地有了以下贪心策略:
            从后往前选, 对于每个题能做就做
        而本题最有启发性的就是如何实现这个贪心策略, 即如何判断这个题能不能做?
        我们可以构建一个辅助数组B, 记录"保底线", 表示只要当前智商 >= B[i], 就能做出后面
        所有题, 这相当于在寻找"结尾连续1"的左端点, 下面我们严格证明在保底线前付费测是不优的
        证: 当q < B[i]时, 付费测是不优的
        因为B[i]是保证后缀连续1的最低阈值, 如果强行选择, 势必导致后缀无法最大化连续1个数
        这与上面证明出的性质矛盾      
*/  
void solve() { 
    int n, q;
    cin >> n >> q;
    vector<int> a(n + 1), b(n + 2), ans(n + 1);
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = n; i >= 1; i--) b[i] = b[i + 1] + (a[i] > b[i + 1]);
    for(int i = 1; i <= n; i++) {
        if(q >= a[i]) ans[i] = 1;
        else if(q >= b[i]) q--, ans[i] = 1;
    }
    for(int i = 1; i <= n; i++) cout << ans[i];
    cout << "\n";
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
    
