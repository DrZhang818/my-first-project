#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> PII;
typedef unsigned long long ull;

    
//https://codeforces.com/contest/1630/problem/A
/*
    构造 || 位运算
    题意:
        给定n和k, 其中n一定是2的幂次, 要求把0~n-1这n个数分成n/2个二元组
        定义一个二元组(a, b)的权值w为a & b
        一种方案是合法的, 当且仅当所有二元组的权值之和∑w = k
        要求构造出一种合法方案, 没有合法方案输出-1
        范围: n∈[4, 2^16], k∈[0, n - 1]
    关键思考:
        本题为构造类题目, 常用思考方式为: 从小规模数据中探寻规律, 从特殊到一般
        分析题目, 很容易发现构造的数据与k的二进制表示有关
        最朴素的想法是, 能否逐位构造二进制k
        例如n = 8, k = 3
        我们考虑能否把011逐位弄出来, 每个二元组解决一个二进制位
        但我们会发现这样数目并不能对齐, 3个二进制位要求3个二元组, 而我们要构造4个
        并且随着n的增大, 这样的差距越来越大, 构造非常复杂
        进而我们又考虑能否利用一个二元组直接构造出k, 剩下的全部为0
        构造k的方案有很多, 只要满足:
        (1)k的二进制为1的位置, a,b都是1
        (2)k的二进制为0的位置, a,b至少一个为0
        构造的原则就是越简单越好, 对于0的位置, 我们不妨让a全为0, b全为1
        这样其实就等价于a = k, b = n - 1
        剩下的工作就是让每个二元组的权值都为0
        我们自然想到, 每个原码 and 反码都是0
        那么在0~n-1意义下, 每个数x的反码就是n - 1 - x, 这是一一映射的关系
        因此我们只要让原码和反码相匹配就能构造出0
        然而, 由于k和n-1我们用过了, 它们的反码就没有相匹配的数了, 需要做一下工作使得反码平衡
        好在我们发现 k的反码n-1-k和n-1的反码0 做位与运算一定也是0, 因为0与任何数与都是0
        
        到这里构造就结束了, 但有一种情况是不满足的:
        当k = n - 1的时候, 二元组(k, n - 1)是相等的两个数, 不合题意
        遇到这种Special Case的时候, 我们尽量在已有基础上进行微调, 这是试错代价最小的一种策略
        既然直接构造k这条路已经被堵死了, 那我们就考虑能否绕一下, 构造出k-1和1
        构造k-1的方法同上, 此时我们用掉了k - 1和n - 1, 打破了反码平衡
        下面的任务就是两件事: (1)构造出1 (2)恢复反码平衡
        我们发现k-1的反码就是1, n-1的反码是0, 直接用这两个是不能构造出1的
        因此我们就要引入两个新的互为反码的数
        这里可以采用3 和 3的反码n-4
        把(1,3)配对能得到1, 再把(n-4,0)配对
        这样我们的任务(1)完成了, 并且两个失衡的反码也得到了解决, 任务(2)也完成了
        剩下的任务就是把其余的互为反码的组成一对输出即可
        
        什么时候无解呢?
        注意到上述做法用到了(n-4), 因此当n = 4的时候, n - 4 = 0重复了, 构造不合法
        可以通过枚举证明n = 4, k = 3一定无解
        对于n > 4的所有情况(n是2的幂), 上述做法一定能得到合法方案, 构造结束
*/
void solve() { 
    int n, k;
    cin >> n >> k;
    vector<bool> vis(n);
    if(n == 4 && k == 3) {
        cout << -1 << "\n";
        return;
    }
    if(k == n - 1) {
        vis[k - 1] = vis[n - 1] = true;
        cout << k - 1 << " " << n - 1 << "\n";
        vis[1] = vis[3] = true;
        cout << 1 << " " << 3 << "\n";
        vis[n - 4] = vis[0] = true;
        cout << n - 4 << " " << 0 << "\n";
    } 
    else {
        vis[k] = vis[n - 1] = true;
        cout << k << " " << n - 1 << "\n";
        if(k != 0) {
            vis[n - 1 - k] = vis[0] = true;
            cout << n - 1 - k << " " << 0 << "\n";
        }
    }
    for(int i = 0; i < n; i++) {
        if(vis[i]) continue;
        cout << i << " " << (n - 1 - i) << "\n";
        vis[i] = vis[n - 1 - i] = true;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
    
