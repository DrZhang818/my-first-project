#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> PII;


//https://codeforces.com/contest/1334/problem/C
/*
    贪心
    题意:
        给定一个整数n表示有n个怪物, 这些怪物站成一个圆圈, 顺时针从1到n依次排列, 起初, 第i个怪物拥有a[i]的生命值.
        你可以射击怪物来杀死它们。每次射击只需要一颗子弹, 并会使目标怪物的生命值减少1。
        此外，当某个怪物的生命值<=0时，它就会死亡并爆炸, 对下一个怪物造成b[i]伤害。
        如果下一个怪物已经死亡, 则不会发生任何事情。
        如果爆炸杀死了下一个怪物，那么它也会爆炸，损坏后面的怪物，并可能触发另一次爆炸，以此类推。
        你必须计算出最少需要发射多少颗子弹才能杀死圆圈中所有的怪物。
    关键思考:
        对于此类决策类问题, 一般就是DP或贪心
        本题是个典型的二维决策问题, 我们希望一个怪物生命越少越好, 爆炸伤害越高越好
        由于是二维, 不能简单地沿着某一个维度进行贪心, 必须发现新的性质去定贪心策略
        一般贪心优化问题都要尝试寻找系统中的不变量, 把不变量隔离出来
        本题的不变量就是"哪些枪一定要打"
        由于每个桶的爆炸伤害只会影响到后一个桶, 那么后一个桶一定要打的次数就是max(0, a[i+1]-b[i])
        由此计算出每个桶必须打的次数, 就隔离出了系统的不变量
        剩下的问题就转换成: 第一枪引爆哪个桶
        因为一旦引爆, 后面就是连锁反应, 填上必须打的次数后就会全部炸光
        由于每个桶有a[i]点生命值, 我们记该桶必须打c[i]枪
        那么引爆它的成本就是a[i]-c[i]
        因此我们只需要找到最小的引爆成本即可
        答案就是一定要打的枪 + 最小引爆成本
*/
void solve(){
    int n;
    cin >> n;
    vector<ll> a(n), b(n);
    for(int i = 0; i < n; i++) {
        cin >> a[i] >> b[i];
    }
    ll ans = 0, mn = LLONG_MAX;
    for(int i = 0; i < n; i++){
        ans += max(0LL, a[(i + 1) % n] - b[i]);
        mn = min(mn, a[(i + 1) % n] - max(0LL, a[(i + 1) % n] - b[i]));
    }   
    cout << ans + mn << "\n";
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while(t--){
        solve();
    }
    return 0;
}

