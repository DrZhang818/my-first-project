#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> PII;
typedef unsigned long long ull;
const int inf = 1000000000;
const int MOD = 1000000007;

//https://atcoder.jp/contests/abc134/tasks/abc134_f
/*
    DP || 组合数学
    题意:
        定义一个1~N的排列p的权值为f(p) = ∑|i-p[i]|, i∈[1,N]
        给定一个整数k, 计算出所有权值为k的排列的数量, 对1000000007取模
        范围: N∈[1,50], k∈[1,N^2]
    关键思考:
        本题为计数类题目, 常用思考方式为: 暴力->DP||组合数学, 常用优化手段为: 前缀和、双指针、数学
        我们可以把排列的下标和排列的值看作二分图匹配
        对于在二分图匹配上的计数问题, 我们又可以转化为盒子装球问题
        这种问题的经典思考方式为: 选定一个合适的视角(小球or盒子or同时)作为最外层枚举对象
        第二个参数往往设计为已经被选/还未被选的个数
        因此我们可以将dp状态设计为:
        f(i,j,s) := 考虑前i个盒子与小球, 剩下j个未匹配, 当前已匹配的权值为s的数量
        然而, 这样朴素的状态定义是不能实现状态转移的, 因为盒子和小球都是不同的
        因此这里使用一种高级dp手段, 在第三个参数s引入"增量贡献"
        对于第i个盒子和第i个小球, 如果它们没有进行匹配, 则钦定它们分别与第i+1个小球和
        盒子进行匹配, 对参数s的增量贡献为2
        换一种更本质的理解方式: 如果第i个盒子与第i+t个小球匹配, 那么得到的贡献是t
        我们在i时刻并不知道t是多少, 但由于t是线性增长的, 我们可以逐步累积增量1
        直到第i+t时刻被选中了, 而这时候累积得到的1*t恰好就是带来的真实贡献
        因此, 重新设计dp状态为: 
        f(i,j,s) := 考虑前i个盒子与小球, 剩下j个未匹配, 增量权值为s的数量
        下面考虑状态转移, 我们使用刷表法, 由已知状态主动向未知状态转移
        也就是, 我们不去想哪些状态能转移到当前状态, 而是由当前状态可以转移到哪些状态
        这是计数类DP极为常用的转移方式
        考虑当前新来的盒子i和小球i, 会产生以下几种情况:
        (1)盒子i与小球i匹配:
            此时未匹配数量保持不变, 增量权值增加2 * j
        (2)盒子i与1~i某个未匹配小球进行匹配, 小球i不匹配:
            此时未匹配数量-1+1保持不变, 增量权值增加2 * j
        (3)小球i与1~i某个未匹配盒子进行匹配, 盒子i不匹配:
            此情况与情况(2)完全相同
        (4)盒子i与1~i-1某个未匹配小球匹配, 小球i与1~i-1某个未匹配盒子匹配:
            此时未匹配数量-1, 增量权值增加2 * (j - 1)
        (5)盒子i与小球i都不匹配:
            此时未匹配数量+1, 增量权值增加2 * (j + 1)
        最后答案即为dp[n][0][k]

*/
void add(int &x, int y) {
    x += y - MOD; x += x >> 31 & MOD;
}
void solve() {
    int n, k;
    cin >> n >> k;
    vector dp(n + 1, vector<vector<int>>(n + 1, vector<int>(k + 1)));
    dp[1][0][0] = 1, dp[1][1][2] = 1;
    for(int i = 2; i <= n; i++) {
        for(int j = 0; j < i; j++) {
            for(int s = 0; s <= k - 2 * (j - 1); s++) {
                if(s + 2 * j <= k) add(dp[i][j][s + 2 * j], dp[i - 1][j][s]);
                if(j) {
                    if(s + 2 * j <= k) add(dp[i][j][s + 2 * j], 1LL * j * dp[i - 1][j][s] * 2 % MOD);
                    if(s + 2 * (j - 1) <= k) add(dp[i][j - 1][s + 2 * (j - 1)], 1LL * j * j * dp[i - 1][j][s] % MOD);
                }
                if(s + 2 * (j + 1) <= k) add(dp[i][j + 1][s + 2 * (j + 1)], dp[i - 1][j][s]);
            }
        }
    }    
    cout << dp[n][0][k] << "\n";
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t = 1;
    while(t--) {
        solve();
    }
    return 0;
}
