#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> PII;


//https://loj.ac/p/10164
/*
    DP || 分治
    题意:
        定义一个数是合法的, 当且仅当这个数满足从左到右各位数字成小于等于的关系
        现给定一个区间[L,R], 要求计算出区间内有多少个合法的数
        范围: L,R∈[1, 2^31 - 1]
    关键思考:
        本题是计数类问题, 常用思考方式为: 暴力->DP||组合数学, 常用优化手段为: 前缀和、二分、数学
        首先考虑暴力的做法:
            枚举L到R内的每个数, 逐一验证合法性
            时间复杂度为O(nlogn), 需要优化
        我们发现瓶颈在于枚举每个数字, 枚举的开销就是O(n)的, 这意味着我们不能逐一枚举
        必须通过巧妙地方式跳过验证, 例如数位DP, 通过直接构造数字来计算哪些是合法的
        数位DP题目的重要手段是利用前缀和, 把计算[L,R]变成计算[1,R]和[1,L-1]
        这样处理后, 便于我们接下来进行分类讨论, 大规模地处理/构造合法数字
        现在问题就变为如何计算[1,n]范围内的合法数字了
        例如n = 24
        这里我们引入"残缺"这一概念, 我们发现最高位是2的时候, 低位是不能任取的, 2X必须满足
        X <= 4, 否则就不在n的范围内, 这时"2"就是残缺的
        而除了2之外, 1和0都不是残缺的, 这时候计算起来就方便很多, 因为缺少了上界后, 我们就
        更加容易利用数字间的性质写出转移方程, 而不必考虑是否超出范围
        因此我们把24分成两部分, 1~19 和 20~24
        DP的思考都是从简单到复杂, 我们先来讨论1~19的处理方法
        我们考虑定义dp[i][j] := 前i个数位中, 第i位填j的方案数
        那么就有转移方程:
            dp[i][j] = Σdp[i - 1][k] (k∈[j,9])
            初始状态: dp[1][j] = 1表示第一位填0~9的方案数都是1
        我们可以预处理出来dp表, 方便后续的查询
        预处理后, 1~19的部分就很好计算了
        枚举最高位(第二位)填0还是1, 结果就是
        dp[2][0] + dp[2][1], 注意这里00这个非法状态也被计入了, 但后续会被减掉
        接下来处理20~24的部分
        这部分是在第i位为j的前提下, 对1~i-1位加入了额外的数值限制
        但我们可以延续上面的思路, 将其继续拆解
        拆分为20~23 和 24两部分
        这样对于20~23这一部分, 可以转化为求解∑dp[1][j] (j∈[2,3])
        最后对于24这一个单独的部分, 我们直接特判即可
        代码实现时, 我们可以很巧妙地把这个几种情况统一起来
        也就是利用pre记录前一个数位的值, cur记录当前数位的值
        根据关系, pre就是j的下界, cur-1就是j的上界
        对于i要从高到低枚举, 可以理解为前cnt - i位已经被填好
        那么1~19这些数就都在i = 2的时候被计算出来了
        20~23的数会在i = 1的时候计算出来
        而进行到i = 1的时候我们可以直接特判i = 0的情况了, 因为此时只有一种状态
        当cur < pre时, 意味着当前数填什么都要比前面的数小, 此时代表后面不会存在合法解
        可以提前剪枝
*/
constexpr int N = 12;
vector<vector<int>> f(N, vector<int>(N));
void init() { 
    for(int i = 0; i <= 9; i++) f[1][i] = 1;
    for(int i = 2; i < N; i++) {
        for(int j = 0; j <= 9; j++) {
            for(int k = j; k <= 9; k++) {
                f[i][j] += f[i - 1][k];
            }
        }
    } 
}   

void solve(int l, int r) {
    vector<int> a(N);
    auto dp = [&](int n) -> int {
        if(n == 0) return 1;
        int cnt = 0;
        while(n) {
            a[++cnt] = n % 10;
            n /= 10;
        }
        int res = 0, pre = 0;
        for(int i = cnt; i >= 1; i--) {
            int cur = a[i];
            for(int j = pre; j < cur; j++) {
                res += f[i][j];
            }
            if(cur < pre) break;
            pre = cur;
            if(i == 1) res += 1;
        }
        return res;
    };
    cout << dp(r) - dp(l - 1) << "\n";
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    init();
    int a, b;
    while(cin >> a >> b) {
        solve(a, b);
    }
    return 0;
}
    
