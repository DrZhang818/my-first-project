#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> PII;


//https://www.luogu.com.cn/problem/P4155
/*  
    倍增DP || 贪心 || 二分 
    题意:
        在圆上给定M个点, 顺时针编号为1~M。 
        有N条线段, 编号依次为1~N, 每条线段由a,b两个参数组成, 表示可以由a点顺时针覆盖到b点
        依次回答N次询问, 每次询问为:
        编号为i的线段必选, 最少需要多少条线段可以覆盖整个圆
        题目保证线段没有包含关系, 并且所有线段全选一定可以覆盖整个圆
        范围: N <= 2e5, M < 1e9, 1 <= a,b <= M
    关键思考:
        本题为决策类题目, 常用思考方式为: 暴力 -> DP || 贪心, 常用优化手段为: 前缀和 + 差分 || 二分 || 双指针 
        对于区间完全覆盖问题, 我们可以考虑以下贪心策略:
            考虑当前选了第i条线段, 那么下一条的左端点应该 ≤ 当前右端点, 并且右端点要选最大的
            这样递归地选下去, 就可以保证答案是最优的
        但对于本题这样的环形区间, 比较方便的做法就是断环成链, 把所有线段克隆一份, 这样就变成了普通的区间覆盖了
        问题是每次贪心的时间是O(n)的, 那么回答n次询问的总时间是O(n^2), 需要优化
        这可以利用倍增的思想来优化, 我们需要快速知道按照最优策略操作k次能到达哪个区间
        最核心的点在于, 最优策略是满足可加性的, 即最优进行3次 = 最优进行2次 + 最优进行1次
        那么就可以把k写成二进制形式, k = a[0]*2^0 + a[1]*2^1 +...+ a[n]*2^n
        并预处理最优进行1,2,4,8...次之后到达的区间, 这样就可以在logk的时间内计算出进行k次到达的区间
            (这一段完全可以用快速幂思想来理解)
        预处理的方法完全就是DP的思想
        定义dp[i][s] := 从第i条线段出发, 进行2^s次操作后到达的线段
        状态转移: dp[i][s] = dp[dp[i][s - 1]][s - 1]

        预处理好后, 就该考虑对于每个线段, 如何计算它的最优操作次数呢?
        这很容易想到二分了, 我们有了O(1)的查询, 那么二分计算的时间复杂度就是log级的
            这里我们举个小例子: 如何用二分计算得到36呢?
            我们可以从大到小的方向进行二分, 初始化答案为0
            0  + 32 <  36, 选上, 答案变为32
            32 + 16 >= 36, 不选
            32 + 8  >= 36, 不选
            32 + 4  >= 36, 不选
            32 + 2  <  36, 选上, 答案变为34
            34 + 1  <  36, 选上, 答案变为35
            最后答案 + 1, 得到36
        ※※※
        对于本题思想完全一样, 我们从大到小进行二分, 但这里我们规定小于终点的才选, 大于等于终点的都不选
        这是因为如果我们二分的时候把小于等于终点的都选上了
        那么我们最后是正好在终点 还是在终点前面? 这其实是需要特判的
        但如果我们定义只选小于终点的, 那么最终一定在终点前面, 并且从这点出发下一步一定会到达或超过终点
        这还是二分的思想, 我们相当于选取了最后一个右端点小于终点的线段, 那么下一条一定就是大于等于终点的线段
        因此二分之后, 答案再加1即可
        注意: 答案要初始化为1, 这是因为起始的线段也算在答案内, 而起始线段是不算操作次数的, 所以不会在二分中计算
*/
struct info{
    int id, l, r;
};
void solve(){
    int n, m;
    cin >> n >> m;
    vector<info> a(2 * n);
    for(int i = 0; i < n; i++) {
        int l, r;
        cin >> l >> r;
        if(r < l) r += m;
        a[i] = {i, l, r};
        a[i + n] = {i, l + m, r + m};
    }
    sort(a.begin(), a.end(), [](const info& x, const info& y) -> bool{
        return x.l < y.l;
    });
    const int N = log2(n);
    vector<vector<int>> dp(2 * n, vector<int>(N + 1));
    for(int i = 0, cur = 0; i < 2 * n; i++) {
        while(cur < 2 * n && a[cur].l <= a[i].r) {
            cur++;
        }
        dp[i][0] = cur - 1;
    }
    for(int s = 1; s <= N; s++) {
        for(int i = 0; i < 2 * n; i++) {
            dp[i][s] = dp[dp[i][s - 1]][s - 1];
        }
    }
    vector<int> ans(n, 1);
    for(int j = 0; j < n; j++) {
        int tar = a[j].l + m;
        int id = a[j].id;
        for(int i = N, cur = j; i >= 0; i--) {
            int nxt = dp[cur][i];
            if(a[nxt].r < tar) {
                ans[id] += (1 << i);
                cur = nxt;
            }
        }
        ans[id] += 1;
    }
    for(auto c : ans) {
        cout << c << " ";
    }
    cout << "\n";
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    solve();
    return 0;
}

